# setproxy TUN 兼容与设计方案（设计笔记）

## 已知问题

TUN兼容性问题
1. 场景缺失：默认假设任何用户“开启系统代理”，未覆盖“关闭系统代理 + 开 TUN 虚拟网卡”或“直连”的场景，默认行为与实际网络可能不匹配。  
6. 缺乏场景引导：文档/参数未直观区分“系统代理 vs TUN vs 直连”，新用户不清楚默认行为，易被默认代理坑到。  
2. 自动开代理：`setup-proxy.sh` 安装末尾默认 `proxy-on`，初始即导出代理变量；在 TUN/直连场景强制走代理。  
7. 默认风险：默认即导出代理，对不熟悉命令的用户存在网络故障风险（代理端口未监听、防火墙拦截等）。

持久化配置问题
3. 重启后丢失配置：代理开关未被可靠持久化，新终端/重启后需要重新操作，体验不一致。  
4. 旧配置干扰：用户自有 `~/.proxy_config` 等被 `~/.zshrc` 自动 source，形成双重配置，难以诊断。  

工具解耦问题
5. 工具级残留：执行 `gitconfig-proxy/npmrc-proxy/pip-proxy ... on` 后，切换到 TUN/直连时仍保留，Brew/Git 继续走代理端口。  

## 设计目标

- 默认安全：开箱不改网络状态，默认直连，避免小白被默认代理坑到。  
- 场景引导而非内置模式：通过文档和`--help`等说明“系统代理/TUN/直连选择什么命令”，不内置复杂 mode/state 逻辑。  

- 单一开关&持久生效：`on/off` 是唯一核心开关，简化安装与使用；持久化生效，不支持“一次性开关”。  
- 兼容旧配置：检测提醒旧版本文件和导出，避免双重配置；持久化位置以 zshrc 标记区为准，清理旧文件。
- 幂等可预期：重复执行不重复插入，开关行为与文档一致。

- 工具配置解耦：工具级代理仅在用户明确选择时执行，对称可关。  
- 工具支持灵活组合：允许用户自己选择配置哪些工具，自由组合。

## 核心思路

- 唯一核心开关：`setproxy.sh on|off`（安装后提供 `setproxy`/`proxy-on`/`proxy-off` 别名，参数行为一致，不包含安装任务）。  
  - 语义：写入/清理 `~/.zshrc` 标记区的导出；同时 set/unset 当前会话。  
  - 默认值：off，且跨会话持久，不提供“一次性”模式。  
- 场景以文档引导：  
  - 系统代理：用 `setproxy on [tools]`。  
  - TUN/直连：保持 `setproxy off`（默认）。  
  - 直连但想清理工具代理：`setproxy off --with git,npm,...`。  
- 工具配置与核心开关解耦：核心 on/off 不自动修改工具；工具仅在用户显式 `--with`（或预设包）时执行对应 `*-proxy on/off`。  
- 不再有独立 state 文件或自动套用逻辑；持久化即为修改 zshrc 片段 + 工具配置。  
- 项目早期，兼容层非必需，合理性优先；旧 flag 可提示后废弃。

## 实现方案

### 基础命令
- `setproxy.sh on|off [options]`（安装后提供 `setproxy`/`proxy-on`/`proxy-off` 别名，行为一致，不包含安装任务；别名应接受相同参数）。  
  - 立即修改 zshrc 标记区（导出或清空），并同步当前 env。  
  - `--port <port>` 覆盖 127.0.0.1:PORT。  
  - 安装/初始化默认等价于 `setproxy off`：只写入函数/别名，标记区为空模板，不导出代理、不改工具。
- 辅助命令：`proxy-status`（优先展示持久化状态，同时展示 env 偏差）、`proxy-test`（不假定默认开启，按当前状态测试）。
- 重复执行 on/off 会直接覆盖现有 setproxy 片段，不再提示；仅遇到旧配置/非交互且需覆盖时才需 `--force`。

### 工具选择与解析
- `--with git,npm,cargo` 或重复 `--with git --with npm`：对选定工具执行 on/off（参数名固定为 `--with`），解析后去重。遇到不支持的工具名直接报错中止，错误文案指出无效值。  
- `--all`：独立布尔开关，含义“核心+所有工具”；不接受 `--with all`。若同时传 `--all` 与 `--with`，直接报错，避免歧义。  
- 取消预设包：`--minimal`（默认即 minimal）、`--recommended`（改为文档/--help 示例，如 `--with git,npm,pip`）。  
- 工具 on/off 对称：仅在用户指定时写入/删除工具代理配置；核心 off 不强制改工具，需用户明确选择。  
- 工具集暂按现有脚本（git/npm/pip/go/docker/cargo），`--all` 即覆盖这些；不额外扩展，未来单独讨论；现有脚本行为保持不变（除非修 bug）。

### 持久化与标记区
- zshrc 标记区：`[BEGIN setproxy]... [END setproxy]`，根据 on/off 写入导出或空模板，幂等更新。  
- 持久化仅通过 zshrc 片段 + 工具配置，不再有 state 文件或自动套用逻辑。

### 当前会话同步与清理
- 执行 on/off 时立即 set/unset 当前 env。  
- `setproxy off`/`proxy-off`：清理当前 env；工具仅在用户传 `--with/--all` 时执行对应 off，默认不动。  
- 核心 off 时可保留工具 on（不覆盖用户特殊配置），文档写清“核心 off 时工具走直连”；若需关工具，使用 `setproxy off --with ...` 或 `--all`。

### 旧配置处理与交互
- 旧版本遗留文件（如 `~/.proxy_config`）：提示后清理（不备份），并移除 `.zshrc` 中的引用，避免残留；无响应则中止。  
- 新版标记区旧内容：展示内容后询问“继续覆盖 / 中止”，无响应则中止，覆盖时不再额外备份（标记区可重建）。  
- 检测已有导出（HTTP_PROXY 等）并提示，防止双重配置。  
- 非交互/CI：能兼容则自动执行；需用户确认的步骤（覆盖旧内容）在无交互时中止，或由显式 `--force` 跳过确认。

### 文档与测试任务
- README/CLAUDE：新增“场景→推荐命令”表；默认 off 说明；核心与工具解耦；旧配置迁移步骤；示例包含 `--with git,npm,pip`。  
- FAQ：为什么关了还生效？如何检查旧导出？如何仅关闭工具代理？  
- 发行说明：强调默认改为直连，需显式 on 才导出。  
- 测试：`test.sh` 更新覆盖持久化 on/off、`--with/--all` 解析、旧配置处理分支；保留 dry-run 调试模式。
